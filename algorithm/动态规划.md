本节主要吸收自修言大佬的掘金小册——前端算法与数据结构面试

什么样的题目可以用动态规划（表象判断）：

1. 要求给出达成目的的**解法个数**
2. 不要求给出每种解法对应的具体路径

动态规划和递归思想的区别在于动态规划是**自底向上的**，由已知的条件，以及**已知和未知之间的关系**（称为状态转移方程），推导出未知的值

抽象后

动态规划的题目的关键特征：

1. **最优子结构**：每个子结构都是最优的解法，依赖于这个子结构的父结构也是最优的
2. **重叠子问题**：使用从后向前递归的时候，引发了重复计算

动态规划题目的分析过程：

1. 找出边界值，也就是已知条件
2. 找出已知条件与未知条件之间的关系，列出状态转移方程
   1. 设置一个记忆数组，用于存放每个子问题的结果，为了消除重叠子问题带来的重复计算
3. 用代码来实现状态转移方程

```js
/**
	硬币问题
	arr 硬币组合，例如[1,2,5]
	total 总金额
	return 最少凑出total金额的硬币数量
	例如 arr [1,2,5] total 11 输出 3 ，因为 5+5+1
*/

const arr = [1,2,5]

const fn = total => {
	// 结果数组一定要有，用来记忆已经计算过的场景
	const f = [] 

	// 边界条件 f(0) = 0
	f[0] = 0 

	/**
		分析：
		设硬币为C1,C2...Cn
		则
		f(n) = Math.min(f(n-C1)+1,f(n-C2)+1,...,f(n-Cn)+1)
		也就是状态转移方程
	*/


	// 获取从1到total，所有的结果
	for (let i = 1; i <= total; i++) {

		// 初始化，占位
		f[i] = Infinity

		// 开始执行状态转移方程
		for(let j=0;j<arr.length;j++) {
			// 只有total >= Cn的时候，才有必要进行计算
			if(i >= arr[j]) {
        // 选取f(n-C1)...f(n-Cn)中最小的一个
				f[i] = Math.min(f[i], f[i - arr[j]] + 1)
			}

		}

	}

	// 如果输出为infinity，则证明输入值没有方案实现，无解
	if (f[total] === Infinity) return -1

	return f[total]

}
```

经典模型：背包问题

有 n 件物品，物品体积用一个名为 w 的数组存起来，物品的价值用一个名为 value 的数组存起来；每件物品的体积用 w[i] 来表示，每件物品的价值用 value[i] 来表示。现在有一个容量为 c 的背包，问你如何选取物品放入背包，才能使得背包内的物品总价值最大？

这种问题和之前总结的动态规划特征有出入，是求一种最优的策略

分析方法和之前略有不同，因为这是求最优策略，所以不需要考虑终止条件，也就是不需要去找边界值

但是一定要找已知和未知之间的关系，得出状态转移方程

这道题有两个自变量，物品索引i和物品总体积w，因变量是总价值v

假设一个最优策略为f(i, c)，即装入第i个物品的时候背包已满

设计一个动作，取出这时候背包中的一个物品i

会得出两种结果：

- 背包中本身就没有i，那么背包总体积不会改变，总价值也不会改变

  即 `f(i, c) = f(i-1, c)`

- 背包中有i，那么体积会变为c-w[i]，价值也会相应减少

  即 `f(i, c) - value[i] = f(i-1, c-w[i])`

  等式变换得 `f(i, c) = f(i-1, c-w[i]) + value[i]`

那么可得状态转移方程：

`dp[i][w] = Math.max(dp[i-1][w], dp[i-1][c-w[i]] + v[i])`

因为有两个因变量，故关系函数为`dp[i][w]`

但是这个`dp[i-1][w]`和`dp[i][w]`相等，后续也用不到这个东西，所以可以二维数组可以简化为一维数组`dp[w]`？？？？？？不明白，后续想清楚了再来更新

将状态转移方程放入循环当中

```js
function backpack(n, c, w, v) {
    // 初始化状态保存数组，位数为c+1是因为会出现dp[c]
    let dp = new Array(c+1).fill(0)
    // 初始化结果
    let res = -Infinity
    for(let i=1; i<=n; i++) {
        // 只有当体积大于w[i]的时候，才有意义
        for(let j=c; j>=w[i], j--) {
            // 状态转移方程
            dp[j] = Math.max(dp[j-w[i]] + v[i],dp[j])
            // 更新最大值
            if(dp[j] > res) res = dp[j]
        }
    }
    return res
}
```

