# 复杂度

复杂度是衡量代码运行效率的度量因素

## 复杂度的衡量维度

1. 代码消耗的资源

   一般而言，代码执行过程中会消耗计算时间和计算空间，也就是**时间复杂度**和**空间复杂度**

2. 代码对资源的消耗是多少

   一段代码输入数据少时，消耗自然会少，通常关注时间和空间的消耗量与输入数据量之间的关系

## 复杂度的计算方法

复杂度是一个关于输入数据量n的函数

若代码的复杂度为O(n)，表示复杂度与计算实例的个数n线性相关，O(logn)表示复杂度与计算实例的个数n对数相关

复杂度计算方法遵循以下几个原则：

1. 复杂度与具体的常系数无关

   O(n)和O(2n)表示的是相同的复杂度

2. 多项式的复杂度相加的时候，选择高者作为结果

   O(n平方)+O(n)和O(n平方)表示的是同样的复杂度

3. O(1)是一种特殊的复杂度，表示代码的复杂度与输入数据量n无关，即可通过有限可数的资源便能够完成某个任务

## 时间复杂度与代码结构的关系

1. 一个顺序结构的代码，时间复杂度为O(1)
2. 二分查找算法的时间复杂度是O(logn)
3. 一个简单的for循环，时间复杂度是O(n)
4. 两个顺序执行的for循环，时间复杂度为O(2n)，实际也是O(n)
5. 两个嵌套的for循环，时间复杂度是O(n平方)

# 数据结构



代码的终极目标是，采用尽可能低的时间复杂度和空间复杂度，来实现功能

复杂度的优先级：**时间昂贵，空间廉价**

空间上的资源消耗可以通过增设服务器等方法来解决，而时间是无法用金钱来衡量的

因此，数据结构是用来解决空间换时间的问题，是链接时间和空间的桥梁

程序优化的最核心思路：

1. 暴力解法，先不考虑时间、空间的约束，完成代码任务的开发
2. 处理无效操作。删除代码中的无效计算，无效存储，降低时间或空间复杂度
3. 时空转换。设计合理的数据结构，完成时间复杂度向空间复杂度的转移

## 代码对数据的处理操作

对一段代码设计合理的数据结构，来降低时间损耗，可以采用以下的思考顺序：

1. 分析代码对数据先后进行了那些操作
2. 根据分析出的数据操作，找到合理的数据结构

代码对数据的处理就是对输入的数据进行计算，得到结果并输出的过程，这个过程总结后分为以下三种操作：

1. 找到需要处理的数据。**查找**
2. 将结果存到一个新的内存空间中。**新增**
3. 将结果存到一个已使用的内存空间中。需要先**删除**内存空间的已有数据，在新增新的数据

增和删操作可以细分为在数据结构中间的增删，和在数据结构最后的增删，位于中间的增删会改变原数据的位置，而末尾的增删则不会

无论是多复杂的代码，对数据的处理无非都是这三种操作，只要围绕这三种操作进行分析，就能得出解决问题的最优方案。

- 这段代码对数据进行了哪些操作？
- 这些操作中，哪个操作最影响效率，对时间复杂度的损耗最大？
- 哪种数据结构最能提高数据操作的效率？

## 线性表（链表）

### 线性表的新增

待插入节点为s，原节点为p

```js
s.next = p.next
p.next = s
```

### 线性表的删除

```js
p.next = p.next.next
```

### 线性表的查询

分为按照位置序号查询和按照值来查询

### 线性表的优劣

可见线性表的查询复杂度为O(n)，需要对全部数据进行遍历

而新增、删除，都需要伴随一个查询的动作，例如删除第5个节点，则需要先找到第5个节点，因此复杂度也是O(n)

**线性表的优势在于数据的存储是按照顺序来进行的。**

适用场景：数据元素个数不确定，且需要经常进行增删操作，比较适合用线性表。

### 线性表案例

1. 链表反转

   方法一：将链表转化成反转起来比较方便的数据结构，例如数组，再重新构造链表，空间复杂度O(n)，时间复杂度O(n)

   方法二：设置三个指针，存放当前节点curr，前一个节点prev，下一个节点next

   ```js
   let curr = node,prev = null,next = null;
   while(curr) {
       next = curr.next;
       curr.next = prev;
   	prev = curr;
       curr = next;
   }
   ```

   这种方法空间复杂度O(1)，时间复杂度O(n)

2. 判断链表是否有环

   可以使用**快慢指针**的方法

   快指针每次后移两个节点，慢指针每次后移一个节点

   如果链表有环，则快指针和慢指针一定会在环内相遇，即fast == slow，反之，直到完成循环之时，两指针都不会相遇

   这种方法，同样可以用来寻找**奇数长度链表的中间节点的问题**，当快指针结束循环的时候，慢指针所处的节点便是中间节点。

## 栈

栈是一种特殊的线性表

特殊性体现在栈的增和删都只能在末尾进行，也就是后进先出

栈的操作相比数组和链表来说更为受限，但正是这种限制，使得栈在某些只涉及增删操作的问题时更加安全，效率更高

### 顺序栈

栈的顺序存储可依靠数组来视线，一般会把数组的首元素存在栈底，最后一个元素放在栈顶，定义一个top指针来指示栈顶元素的位置

当top为-1时，栈为空，top为0时，栈内只有一个元素；当定义了栈的最大容量为StackSize时，top须小于size

插入元素的时候，将新元素置于栈顶，top+1；删除元素的时候，只需要top-1

### 链式栈

即用链表的方式来表示一个栈

可将栈顶放在链表的头部，由于栈后进先出的规则，原先的头部指针变得没有意义

每次新增节点，需要将新节点的next指向原栈顶节点，再将top指针指向新节点；删除节点时，则直接将top指向栈顶的next节点

### 栈案例

1. 字符串括号匹配问题，见LeetCode

2. 浏览器页面前进后退问题

   如果按照先后顺序依次访问1,2,3,4,5 5个页面，先回退到3页面，再前进到4页面

   这时候需要维护两个栈，前进栈和回退栈

   每访问一个新页面，就在前进栈中执行入栈操作，每次回退，便在前进栈中执行出栈，并将出栈的元素压入到回退栈中，再前进，再在回退栈出栈，并把出栈元素压入到前进栈

## 队列

队列也是特殊的线性表，执行增删操作的顺序是先进先出

先进：新增操作只能在末端进行，不能在队列的中间节点进行新增

先出：删除操作只能在首部进行，不能删除队列的中间节点

队列同样存在顺序队列和链式队列

链式队列也可依靠数组实现，新增操作用push，删除操作用shift（JavaScript）；循环队列依赖头指针front和尾指针rear进行唯一确定，当队列为空时，两个指针都指向头结点

### 队列案例

约瑟夫环问题

已知 n 个人（以编号 1，2，3...n 分别表示）围坐在一张圆桌周围。从编号为 k 的人开始报数，数到 m 的那个人出列；他的下一个人又从 1 开始报数，数到 m 的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。

在可以确定队列长度最大值的时候，选择循环队列，其他情况下选择用链式队列

## 数组

数组在存储时按照顺序存储，并且存储数据的内存也是连续的，因此具有增删困难，查找容易的特点。

### 数组的基本操作

新增

1. 在数组的最后增加一个新的元素，对原数组没有任何影响，时间复杂度为O(1)
2. 在数组中间某个位置新增元素，因为会对插入元素位置之后的元素产生影响，因此复杂度为O(n)

删除，与新增类似

查找，可以通过元素的下标索引，直接在O(1)复杂度内查找到某个位置的元素，但如果需要根据数值去查找满足条件的数据，则复杂度也是O(n)

## 字符串

由n个字符组成的一个有序整体

存储结构与线性表相同，同样分为顺序存储和链式存储

顺序存储：用一组地址连续的存储单元来存储串中的字符序列，一般用定长数组来实现

链式存储，与线性表相似，但为了避免空间浪费，会在一个节点存储多个字符，如果最后一个节点没被占满，可以使用其他非串值字符补全

### 字符串的基本操作

字符串针对的是字符集，所有元素都是字符，因此，基本操作与线性表有很大区别。

线性表关注的是单个元素的操作，而字符串更多关注查找子串的位置、替换等操作

新增：同数组类似，涉及到对插入字符串之后字符的挪移操作，故时间复杂度为O(n)；如果是在一个字符串的最后插入另一个字符串，也叫字符串的连接，复杂度则是O(1)

删除，和新增类似

字符串查找，也就是字符串匹配，或称子串查找

在字符串 A 中查找字符串 B，则 A 就是主串，B 就是模式串。我们把主串的长度记为 n，模式串长度记为 m。由于是在主串中查找模式串，因此，主串的长度肯定比模式串长，n>m。因此，字符串匹配算法的时间复杂度就是 n 和 m 的函数。

- 从主串的第一位开始，判断A的第一个字符是否与B的第一个字符相等
- 如果不相等，判断A的第二个字符是否与B的第一个字符相等，直到在A中找到一个与B第一个字符相等的位置
- A和B均向后匹配，若途中出现有一个字符匹配失败，则重复之前的动作

```js
function matchString(A,B) {
    let i=0,j=0,index=0;
    while(i<A.length) {
        index = i;
        while(j<B.length) {
            if(A[i] != B[j]) {
                i = index + 1;
                j = 0;
                break;
            } else {
                i++;
                j++
            }
        }
        if(j == B.length) return true
    }
    return false
}
```

## 树

树是由结点和边组成，不存在环的一种数据结构

树结构满足递归定义的特型。如果一个数据结构是树，剔除掉根节点后，得到的若干子结构也是树，称为子树

存储二叉树有两种方式

- 链式存储：像链表一样，每个节点分别有值，左子节点和右子节点

- 顺序存储：按照规律把节点存放在数组里，约定将根节点放在下标为1的位置

  顺序存储的规律：如果节点下标为i，则其左子节点的下标为2i-1，右子节点的下标为2i

完全二叉树与与非完全二叉树的区别在于，完全二叉树只有下标0的存储位置没有使用

![](https://s0.lgstatic.com/i/image/M00/1F/E1/CgqCHl7nVhyAF-yqAAFEIfF2-z4697.png)

### 树的基本操作

遍历

因为树是一对多的数据结构，只有解决了遍历问题，才能保证每个数据都被访问到

-----------------

这里复制在公司做的树的遍历文档

-------------------

二叉树的遍历，时间复杂度是O(n)，找到位置以后执行增删操作，时间复杂度为O(1)

当二叉树具备一些特殊性质的时候，可以利用这些特性降低查找的时间复杂度

**二叉搜索树**（查找树）

具有以下几个性质：

1. 任意一个节点，其左子节点的值小于当前节点，右子节点的值大于当前节点
2. 尽可能避免两个节点数值相等的情况
3. 对二叉搜索树进行中序遍历，可以输出一个从小到大的有序队列数据

对二叉搜索树进行查找，可以进行如下流程

1. 判断根节点是否等于要查找的值，是就返回
2. 如果小于根节点，便在左子树进行递归查找，直到找到该节点
3. 如果大于根节点，便在右子树进行递归查找，直到找到该节点

由此可知，时间复杂度降为O(logn)

二叉搜索树的插入：从根结点开始，如果要插入的数据比根结点的数据大，且根结点的右子结点不为空，则在根结点的右子树中继续尝试执行插入操作。直到找到为空的子结点执行插入动作。

二叉搜索树的删除可分为三种情况

1. 删除叶子结点，直接将其父节点指向null

2. 删除只有一个子节点的节点。将其父节点的指针指向待删除节点的子节点

3. 删除具有两个子节点的节点。

   方法有两种：

   1. 找到该节点左子树中最大的节点，替换要删除的节点
   2. 找到该节点右子树中最小的节点，替换要删除的节点

### 树的案例

1. 输入一个字符串，判断它在已有的字符串集合中是否出现过?（假设集合中没有某个字符串与另一个字符串拥有共同前缀且完全包含的特殊情况，例如 deep 和 dee。）如，已有字符串集合包含 6 个字符串分别为，cat, car, city, dog,door, deep。输入 cat，输出 true；输入 home，输出 false。

   暴力解法的复杂度为O(nm)，可采用树结构来降低复杂度

   对字符串集合建立一个树结构，每个根节点到叶子结点的链条就是一个字符串

   ![Trie树](https://s0.lgstatic.com/i/image/M00/1F/E1/CgqCHl7nVuSASW8lAADCDPk2Zv0987.png)

   这种树称为Trie树或字典树，有以下几个特征：

   - 根节点不包含字符
   - 除根节点外每个节点包含一个字符
   - 从根节点到某一叶子结点，路径连接起来就是集合中的一个字符串
   
   因此这类问题的解法可以分为两步：
   
   1. 构建字典树
   2. 判断一个字符串能否从这棵树走到叶子结点，如果能，则出现过
   
   使用字典树，时间复杂度为构建树O(n) + 查找树O(m)

## 哈希表

哈希表是一种特殊的数据结构，它采用了函数映射的思想，将数据的存储位置与数据的关键字进行映射，能够快速定位到想要查找的记录

哈希表的核心思想是：实现 **地址 = f(关键字)**的映射关系，可以立刻通过关键字查找到相应的地址，省去与集合中其他节点进行比较的过程

哈希表查找的复杂度为O(1)

不同的哈希表，有不同的实现映射关系的方法，也就是不同的哈希函数，但需要避免的是哈希冲突

常用的设计哈希函数的方法有：

- 直接定制法

  哈希函数为从关键字到地址的线性函数。例如H (key) = a*key + b，a和b都是常数

- 数字分析法

- 平方取中法

- 折叠法

- 除留余数法

解决哈希冲突的方法有：

- 开放定址法

  当一个关键字和另一个关键字发生冲突的时候，使用某种探测技术在哈希表中形成一个探测序列，然后沿着探测序列查找下去，直到碰到一个空的单元，将其插入

- 链地址法

  将哈希地址相同的数据存放在一个链表中

哈希表的基本操作

增删操作，不涉及增删后对数据的挪移，可以直接处理

查找操作，对于给定的key，根据哈希函数查找key的哈希地址，如果地址为空，则查找失败，反之则查找成功

三种操作均是O(1)的复杂度

哈希表的应用场景：不需要有序遍历数据，并且可以提前预测数据量的大小

# 算法思想

有了合适的数据结构，也需要合适的数据处理思路来降低算法复杂度

## 递归

递归是指在函数的定义中调用函数自身的方法，直观地看，就是某个函数自己调用自己

递归的基本思想：把规模大的问题转化成规模小的子问题来解决，且解决问题的函数必须有明确的结束条件，否则会造成无限递归。

因此递归的实现包含两部分：

1. **递归的主体**
2. **终止条件**

案例：斐波那契数列

斐波那契数列是：0，1，1，2，3，5，8，13，21，34，55，89，144……。你会发现，这个数列中元素的性质是，某个数等于它前面两个数的和；也就是 a[n+2] = a[n+1] + a[n]。至于起始两个元素，则分别为 0 和 1。在这个数列中的数字，就被称为斐波那契数。

写一个函数，输入 x，输出斐波那契数列中第 x 位的元素。例如，输入 4，输出 2；输入 9，输出 21。

```js
function getFibonaciNum(i) {
	if(i == 1) return 0;
    if(i == 2) return 1;
    return getFibonaciNum(i-1) + getFibonaciNum(i-2);
}
```

## 分治法

核心思想：**分而治之，先将一个难以直接解决的大问题，分解成一些可以直接解决的小问题。如果分割后的问题依然无法解决，那么继续递归地分割，直到每个小问题都可解**

分治法的价值在于大规模数据的处理上，降低的成本才能得到体现

可用分治法解决的问题一般具备如下几个特征：

1. 难度在降低
2. 问题可分
3. 解可合并。子问题的解，可以合并出原问题的解
4. 相互独立。某个子问题的解不会影响到其他子问题的解

分治法的最常用案例就是二分查找

二分查找具有以下几点规律：

- 二分查找的时间复杂度为O(logn)
- 二分查找循环次数不确定，一般是达到某个条件会跳出循环。多半会采用while+break的结构
- **二分查找的原问题数据必须是有序的。**

tips：二分法取中位数：low + (high - low) / 2

## 排序

衡量排序算法的优劣，将从以下三个角度进行：

1. 时间复杂度：最好时间复杂度，最坏时间复杂度，平均时间复杂度
2. 空间复杂度
3. 稳定性：相等的数据对象，排序之后，顺序是否保持不变

### 冒泡

思想：从第一个数据开始，依次比较相邻元素的大小，如果前者大于后者，则交换元素的顺序，直到没有交换为止

```js
function bubbleSort(arr) {
    for(let i=0;i<arr.length-1;i++) {
        for(let j=0;j<arr.length-1;j++) {
            if(arr[j] > arr[j+1]) {
                let temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp
            }
        }
    }
    return arr
}
```

**性能分析**

时间复杂度：最好O(n)，最坏O(n×n)，平均O(n×n)

空间复杂度：O(1)

稳定性：稳定

### 插入排序

思想：选取未排序的元素，插入到已排序区间的合适位置，直到未排序区间为空

从左到右维护一个已经排好序的序列，直到所有待排序元素都执行了插入动作

![](https://s0.lgstatic.com/i/image/M00/29/10/CgqCHl75xmqAXrQnAB7zyryidSU192.gif)

```js
function insertSort(arr) {
    for(let i=1; i<arr.length;i++) {
        let temp = arr[i]
        let j=i-1
        for(;j>=0;j--) {
            if(arr[j] > temp)
                arr[j+1] = arr[j] // 只要前面的比后面的大，就把后面的值换成前面的值
           	else
                break;
        }
        arr[j+1] = temp // 把基准值插入到有序列中
    }
    return arr
}
```

**性能分析**

时间复杂度：最坏O(n×n)，最好O(n)，平均O(n×n)

空间复杂度：O(1)

稳定性：稳定



