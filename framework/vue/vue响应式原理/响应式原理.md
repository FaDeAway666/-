# 数据驱动

数据响应式：

数据模型是普通的js对象，当修改收据的时候，视图会进行更新，避免操作DOM，提高开发效率

双向绑定：

数据改变，视图改变；视图改变，数据也随之改变（v-model）

数据驱动是Vue最独特的特性之一，开发过程中仅需要关注数据本身，不需要关心数据如何渲染到视图

# 响应式核心原理

## Vue 2.x

使用Object.defineProperty的getter、setter来注册data的响应式，因为Object.defineProperty是ES5中无法 shim 的一个特性，也就是Vue不支持IE8及更低版本浏览器的原因

## Vue 3.0

使用Proxy，直接监听data对象，而非对象的属性

Proxy是ES6新增的特性，不支持IE，性能由浏览器优化，比defineProperty性能更好



# 发布订阅和观察者模式

发布订阅：

假定存在一个信号中心，当某个任务执行完成，就向信号中心发布一个信号，其他任务可以向信号中心订阅这个信号，从而指导什么时候可以开始任务，这就是发布订阅模式

Vue自定义事件使用的就是发布订阅模式，兄弟组件之间传值使用的也是发布订阅

观察者模式：没有事件中心

观察者（订阅者） --Watcher

- update() ：当事件发生时，需要进行的操作

目标（发布者）--Dep

- subs 数组：存储所有的观察者
- addSub(): 添加观察者
- notify(): 当事件发生，调用所有观察者的update方法

**两个模式的区别**

- 观察者模式是由具体目标调度，当事件触发，发布者就会去调用观察者的方法，两者之间存在依赖关系
- 发布订阅模式统一由调度中心调用，发布者和订阅者不需要知道对方的存在

![image-20210106112525083](.\images\image-20210106112525083.png)

观察者模式的代码如下：

```js
// 发布者
class Dep {
    constructor() {
        this.subs = []
    }
    
    addSub(sub) {
        if(sub && sub.update) {
            this.subs.push(sub)
        }
    }
    
    notify() {
        this.subs.forEach(sub => {
            sub.update()
        })
    }
}
// 观察者
class Watcher {
    update() {
        console.log('update')
    }
}
```

# Vue响应式原理模拟

Vue最小成员结构

![image-20210106114131250](\images\image-20210106114131250.png)

Vue：将data中的成员注入到Vue实例，并将data中的成员转成getter/setter

Observer：能够对数据对象的所有属性进行监听，如果有变动可以拿到最新值并通知Dep

Compiler：解析每个元素中的指令和插值表达式，并转化为数据

Dep：添加Watcher，一旦接收到数据变动，调用Watcher的update方法

Watcher：接收到Dep的update命令，更新视图

## Vue

功能：

- 负责接收初始化参数（选项）
- 负责将data中的属性注入到Vue实例，转换成getter/setter
- 调用Observer监听data中属性的变化
- 调用Compiler解析指令与插值表达式